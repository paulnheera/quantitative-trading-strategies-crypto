---
title: "SMA Cross-over strategy - Vectorised backtest"
author: "Paul Nheera"
date: "5/26/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#Libraries:
library(readr)
library(ggplot2)
library(quantmod)
library(dplyr)
library(PerformanceAnalytics)
```


```{r}
# Import data:
data <- read_csv("Kucoin_BTCUSDT_1H_data.csv")

#market_data
#indicators
#market_stats - e.g. return, std dev, etc
```

```{r}
# Plot the closing price:
p <- ggplot(data, aes(x=Time,y=Close))+
  geom_line(col='blue') +
  ggtitle('Closing price')

p
```

## Simple Moving Average Cross Over Strategy

```{r}
# Calculate indicators:
data$fastSMA = SMA(data$Close,100)
data$slowSMA = SMA(data$Close,200)
```


```{r}
# Plot with moving averages:
p <- ggplot(data, aes(x=Time,y=Close))+
  geom_line(col='black') +
  ggtitle('Closing price') +
  geom_line(aes(x=Time,y=fastSMA), col='red')+
  geom_line(aes(x=Time,y=slowSMA), col='blue')

p
```

```{r}
# Vectorised back test:

position = data.frame(Time = data$Time, Position= ifelse(data$fastSMA > data$slowSMA, 1,-1))

# We need to lag the position vector in a vectorised back test to avoid look ahead bias!
position$Position = lag(position$Position)

# convert NAs to zero
#position$Position[is.na(position$Position)] <- 0

# returns (1 time period returns)
ret = data.frame(Time=data$Time, Return = ROC(data$Close,n=1,type ='discrete'))

# strategy returns:
strat_ret = data.frame(Time=position$Time, Return= position$Position * ret$Return)
```

```{r}
# Performance analysis:

ggplot(strat_ret, aes(x=Return))+
  geom_histogram(bins=100, fill='blue')

# add Mean, Mode, Median, Quartiles
```


```{r}
# Replace NAs with zero
strat_ret <- strat_ret %>% 
  mutate(Return = ifelse(is.na(Return),0,Return))
  
  
# Calculate cumulative return
strat_ret <- strat_ret %>% 
  mutate(Cum_Ret = cumprod(1 + Return))

# determine start and end date
indx <- which(strat_ret$Return != 0)
start_time = strat_ret$Time[indx[1]]
end_time = strat_ret$Time[nrow(strat_ret)]
```

```{r}
# Plot Strategy Performance:
ggplot(strat_ret, aes(x=Time,y=Cum_Ret)) +
  geom_line()
```

```{r}
# Performance stats:

## Total Cumulative Return:
Return.cumulative(strat_ret$Return)
```
```{r}
# Function to identify trades:

# old function
get_trades <- function(position){
  
  temp <- (position != stats::lag(position))
  temp <- index(position)[which(temp==TRUE)]
  
  start <- temp[seq(from = 1,length(temp),by=2)]
  end <- temp[seq(from = 2,length(temp),by=2)]
  
  if(length(start) > length(end)) end = c(end,NA)
  
  trades <- data.frame(start=start,end=end,position = position[start])
  
  return(trades)
}


# new trades function
get_trades <- function(pos){
  
  r = rle(as.vector(pos))
  s = cumsum(r$lengths)
  
  start <- c(1,(s + 1))
  start <- start[-length(start)]
  end <- s
  
  trades <- data.frame(start_indx=start, end_indx=end,start=index(pos)[start], end=index(pos)[end], position = r$values)
  
  return(trades)
  
}

# replace NAs with zeros 
position$Position[is.na(position$Position)] <- 0
trades <- get_trades(position$Position)

# Add stats to returns data frame.
for( i in 1:nrow(trades)){
  
  temp = ret$Return[c(trades$start_indx[i]:trades$end_indx[i])]
  temp[is.na(temp)] <- 0
                      
  trades$R[i] <- Return.cumulative(temp)
  
}

# Calculate profit
trades <- trades %>% 
  mutate(profit = position*R)

# Check total return
Return.cumulative(trades$profit,geometric = F)

```

```{r}
# Add costs:

trades <- trades %>% 
  mutate(costs = 0.002) %>% 
  mutate(net_profit = profit - costs)

# Total Net Return
Return.cumulative(trades$net_profit,geometric = F)
```

